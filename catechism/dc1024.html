<!DOCTYPE html>

<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>10월 24일 | 보이는 교회의 혼합과 타락과 보존</title>
<link as="style" crossorigin="" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css" rel="stylesheet"/>
<script src="https://cdn.tailwindcss.com"></script>
<style>
        body {
            font-family: 'Pretendard', sans-serif;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">
<div class="container mx-auto max-w-3xl px-4 py-8">
<header class="text-center mb-8">
<h1 class="text-4xl font-bold text-gray-900">10월 24일</h1>
<p class="text-xl text-gray-600 mt-2">보이는 교회의 혼합과 타락과 보존</p>
</header>
<section class="bg-white p-6 rounded-lg shadow-md mb-6" id="audio-player-section">
<h2 class="text-2xl font-semibold mb-4">AI요약 듣기</h2>
<div class="flex items-center space-x-4" id="player-ui">
<button aria-label="교리 오디오 재생/일시정지" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-full w-28 transition-opacity duration-300" disabled="" id="play-pause-button">
                    로딩 중...
                </button>
<div class="w-full bg-gray-200 rounded-full h-2.5">
<div class="bg-blue-600 h-2.5 rounded-full" id="progress-bar" style="width: 0%"></div>
</div>
</div>
<div class="hidden" id="player"></div>
<div class="hidden text-red-500 mt-4" id="error-message"></div>
</section>
<section class="bg-white p-6 rounded-lg shadow-md mb-6">
<h2 class="text-2xl font-semibold mb-4 text-blue-800">신앙고백서 25.5</h2>
<div class="space-y-4 text-lg leading-relaxed">
<p>하늘 아래 가장 순수한 교회일지라도 혼합과 오류 아래 있다. 어떤 교회들은 그리스도의 교회가 아니라 사탄의 회당(會黨)이 될 정도로 타락하기도 했다. 그럼에도 이 땅에는 하나님의 뜻에 따라서 하나님을 예배하는 교회가 항상 있을 것이다.</p>
</div>
</section>
<section class="bg-white p-6 rounded-lg shadow-md mb-6">
<h2 class="text-2xl font-semibold mb-4 text-blue-800">교리 해설</h2>
<div class="space-y-6 text-lg leading-relaxed">
<p>
                    종교개혁자들은 순수한 교회를 추구했지만, 이 세상에서는 완전한 교회를 세울 수 없다는 현실을 분명히 인식했습니다. 오늘의 신앙고백서는 이 땅의 교회가 가진 한계와 타락의 가능성, 그리고 그럼에도 불구하고 교회를 보존하시는 하나님의 신실하심을 가르칩니다.
                </p>
<div>
<strong class="text-xl block text-gray-900">(1) 가장 순수한 교회도 혼합과 오류 아래 있다</strong>
<div class="pl-4 mt-2 space-y-3 border-l-4 border-blue-100">
<p>이 땅의 어떤 교회도 완전하게 순수할 수는 없습니다. 교회를 구성하는 성도 개개인이 중생했을지라도 여전히 죄의 연약성을 지니고 있기 때문입니다. 이 사실은 교회 개혁에 임할 때 교만하거나 쉽게 낙담하지 말고, 겸손과 소망을 가지고 꾸준히 나아가야 함을 교훈합니다.</p>
<p>초대교회 당시, 배교자를 용납한 교회를 비순수하다고 정죄하며 분리했던 <strong class="text-blue-600">도나투스파</strong>의 사례는 다른 교회를 경솔하게 판단하는 위험을 보여줍니다. 교회는 서로의 연약함을 사랑으로 살피며 함께 개혁을 이어가야 합니다.</p>
<p>종교개혁자들 역시 자신들이 세우는 교회가 완전하지 않음을 알았기에, "개혁된 교회는 항상 하나님의 말씀에 따라 개혁되어야 한다"는 원칙을 중요하게 여겼습니다.</p>
</div>
</div>
<div>
<strong class="text-xl block text-gray-900">(2) "사탄의 회당"이 될 정도로 타락할 수 있다</strong>
<div class="pl-4 mt-2 space-y-3 border-l-4 border-blue-100">
<p>교회는 그 순수성을 잃고 타락하여 더 이상 그리스도의 교회가 아닌 <strong class="text-blue-600">‘사탄의 회당’</strong>이 될 수 있습니다. 타락의 정도를 판단하는 기준은 교회의 참된 표지인 '복음 진리의 순수성', '성례와 규례의 합법적 시행', '예배의 규정적 원리 충실성'입니다.</p>
<p>이러한 표지들이 완전히 무너져 복음의 진리가 사라지고, 성례가 인간적인 의식으로 전락하며, 예배가 우상숭배와 왜곡된 지식으로 채워진다면, 그 공동체는 교회의 이름을 가졌을지라도 <strong class="text-blue-600">‘사탄의 회당’</strong>이라 할 수 있습니다. 북이스라엘의 여로보암이 금송아지를 세워 여호와라 칭하며 제사하게 한 것이 그 대표적인 예입니다.</p>
</div>
</div>
<div>
<strong class="text-xl block text-gray-900">(3) 그럼에도 하나님은 항상 교회를 보존하신다</strong>
<div class="pl-4 mt-2 space-y-3 border-l-4 border-blue-100">
<p>특정 지역의 교회가 심하게 타락할 수는 있어도, 하나님께서는 이 땅의 보편적인 보이는 교회를 결코 버리지 않으십니다. 교회의 보존은 인간의 능력이 아닌 전적인 하나님의 섭리에 달려 있습니다.</p>
<p>하나님께서는 가장 어두운 시대에도 항상 <strong class="text-blue-600">‘남은 자’</strong>를 보존하셔서 언약 공동체의 맥이 끊어지지 않게 하십니다. 엘리야 시대에 바알에게 무릎 꿇지 않은 칠천 명을 남겨두셨고(왕상 19:18), 중세 암흑기에도 왈도파, 위클리프, 후스 같은 개혁의 씨앗을 남겨두셨습니다. 비록 현실에서는 배교가 만연해 보여도, 하나님의 섭리 안에서 참된 교회는 언제나 계속됩니다.</p>
</div>
</div>
</div>
</section>

<footer class="text-center mt-8 text-sm text-gray-500">
<p>교재는 날마다 양식으로 읽는 웨스트민스터 표준교리(영음사)를 사용합니다</p>
</footer>
</div>
<script>
        const tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        const firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

        let player;
        let progressInterval;
        const playPauseButton = document.getElementById('play-pause-button');
        const progressBar = document.getElementById('progress-bar');
        const errorMessageDiv = document.getElementById('error-message');
        const playerUi = document.getElementById('player-ui');

        function onYouTubeIframeAPIReady() {
            loadVideoForToday();
        }

        async function loadVideoForToday() {
            try {
                const response = await fetch('../address/dcaddr.txt');
                if (!response.ok) {
                    throw new Error('Audio address file could not be loaded.');
                }
                const data = await response.text();
                const lines = data.split('\n');
                
                const todayKey = '1024';

                // --- 수정된 부분 시작 ---
                // '1021'로 시작하는 줄을 찾습니다 (공백이나 '=' 모두 처리).
                const todayLine = lines.find(line => line.trim().startsWith(todayKey));
                
                if (!todayLine) {
                    throw new Error('not_uploaded');
                }

                // 날짜(키) 부분을 제외하고 나머지(URL)를 추출합니다.
                let url = todayLine.substring(todayKey.length).trim();
                // 맨 앞에 '=' 문자가 있다면 제거합니다.
                if (url.startsWith('=')) {
                    url = url.substring(1).trim();
                }
                // --- 수정된 부분 끝 ---

                const videoId = extractVideoID(url);

                if (!videoId) {
                    // URL은 찾았으나 비디오 ID 추출에 실패한 경우
                    throw new Error('Invalid YouTube URL in dcaddr.txt');
                }
                
                player = new YT.Player('player', {
                    height: '0',
                    width: '0',
                    videoId: videoId,
                    playerVars: {
                        'playsinline': 1
                    },
                    events: {
                        'onReady': onPlayerReady,
                        'onStateChange': onPlayerStateChange
                    }
                });

            } catch (error) {
                playerUi.classList.add('hidden');
                errorMessageDiv.classList.remove('hidden');
                if (error.message === 'not_uploaded') {
                    errorMessageDiv.textContent = '오늘의 AI요약 음성은 아직 업로드 전입니다.';
                } else {
                    errorMessageDiv.textContent = '오디오를 불러오는 중 오류가 발생했습니다.';
                    console.error('Error loading video:', error);
                }
            }
        }

        function extractVideoID(url) {
            // 다양한 YouTube URL 형식에서 비디오 ID를 추출하는 정규식
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
            const match = url.match(regExp);
            return (match && match[2].length === 11) ? match[2] : null;
        }

        function onPlayerReady(event) {
            playPauseButton.disabled = false;
            playPauseButton.textContent = '재생';
            playPauseButton.setAttribute('aria-label', '교리 오디오 재생');
            
            playPauseButton.addEventListener('click', togglePlayPause);
        }

        function onPlayerStateChange(event) {
            if (event.data === YT.PlayerState.PLAYING) {
                playPauseButton.textContent = '일시정지';
                playPauseButton.setAttribute('aria-label', '교리 오디오 일시정지');
                progressInterval = setInterval(updateProgressBar, 1000);
            } else {
                playPauseButton.textContent = '재생';
                playPauseButton.setAttribute('aria-label', '교리 오디오 재생');
                clearInterval(progressInterval);
                if (event.data === YT.PlayerState.ENDED) {
                    progressBar.style.width = '100%';
                }
            }
        }

        function togglePlayPause() {
            if (player.getPlayerState() === YT.PlayerState.PLAYING) {
                player.pauseVideo();
            } else {
                player.playVideo();
            }
        }

        function updateProgressBar() {
            if (player && player.getDuration) {
                const currentTime = player.getCurrentTime();
                const duration = player.getDuration();
                const progress = (currentTime / duration) * 100;
                progressBar.style.width = progress + '%';
            }
        }
    </script>
</body>
</html>
