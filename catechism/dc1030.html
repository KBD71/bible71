<!DOCTYPE html>

<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>10월 30일 | 현세에서 누리는 그리스도와 함께하는 영광의 교제</title>
<link as="style" crossorigin="" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css" rel="stylesheet"/>
<script src="https://cdn.tailwindcss.com"></script>
<style>
        body {
            font-family: 'Pretendard', sans-serif;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">
<div class="container mx-auto max-w-3xl px-4 py-8">
<header class="text-center mb-8">
<h1 class="text-4xl font-bold text-gray-900">10월 30일</h1>
<p class="text-xl text-gray-600 mt-2">현세에서 누리는 그리스도와 함께하는 영광의 교제</p>
</header>
<section class="bg-white p-6 rounded-lg shadow-md mb-6" id="audio-player-section">
<h2 class="text-2xl font-semibold mb-4">AI요약 듣기</h2>
<div class="flex items-center space-x-4" id="player-ui">
<button aria-label="교리 오디오 재생/일시정지" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-full w-28 transition-opacity duration-300" disabled="" id="play-pause-button">
                    로딩 중...
                </button>
<div class="w-full bg-gray-200 rounded-full h-2.5">
<div class="bg-blue-600 h-2.5 rounded-full" id="progress-bar" style="width: 0%"></div>
</div>
</div>
<div class="hidden" id="player"></div>
<div class="hidden text-red-500 mt-4" id="error-message"></div>
</section>
<section class="bg-white p-6 rounded-lg shadow-md mb-6">
<h2 class="text-2xl font-semibold mb-4 text-blue-800">대요리문답 83</h2>
<div class="space-y-4 text-lg leading-relaxed">
<p><strong class="font-bold">문:</strong> 보이지 않는 교회의 지체들이 현세에서 누리는 그리스도와 함께하는 영광의 교제는 무엇입니까?</p>
<p><strong class="font-bold">답:</strong> 보이지 않는 교회의 지체들은 이들의 머리이신 그리스도의 지체이므로 현세에서 그리스도와 함께하는 영광의 첫 열매들을 나누며 누립니다. 그래서 그리스도 안에서 그분이 온전히 소유하신 영광을 누릴 권리를 가지며, 그 보증으로 하나님의 사랑을 느끼고, 양심의 평화와 성령 안에서의 기쁨과 영광의 소망을 누립니다. 반면에 악인들은 복수하시는 하나님의 진노에 대한 지각, 양심의 공포, 다가오는 심판에 대한 두려움을 가집니다. 이것들은 악인들이 죽은 후에 당할 고통의 시작입니다.</p>
</div>
</section>
<section class="bg-white p-6 rounded-lg shadow-md mb-6">
<h2 class="text-2xl font-semibold mb-4 text-blue-800">교리 해설</h2>
<div class="space-y-6 text-lg leading-relaxed">
<p>
                    대요리문답 83항은 <strong class="text-blue-600">‘보이지 않는 교회’</strong>의 지체, 즉 참된 성도들이 단순히 종말을 기다리는 수동적인 삶이 아니라, 이 세상에서부터 그리스도와 함께하는 영광의 교제를 적극적으로 누림을 가르칩니다. 반대로 악인들은 이미 이 세상에서부터 심판의 전조를 경험하게 됩니다.
                </p>
<div>
<strong class="text-xl block text-gray-900">(1) 성도가 누리는 영광의 첫 열매</strong>
<div class="pl-4 mt-2 space-y-3 border-l-4 border-blue-100">
<p>성도는 현세에서 장차 완성될 영광의 <strong class="text-blue-600">‘첫 열매’</strong>를 미리 맛보며 살아갑니다. 이 첫 열매는 미래의 더 큰 영광을 약속하는 보증의 의미를 갖습니다. 그리스도의 부활이 성도의 부활을 보증하는 ‘첫 열매’가 되듯이(고전 15:20), 성도가 받은 ‘성령의 첫 열매’(롬 8:23)는 장차 올 몸의 속량을 보증합니다.</p>
<p>여기서 <strong class="text-blue-600">‘성령의 첫 열매’</strong>란 성령 하나님 자신이라기보다, 그분의 내주하심으로 인해 주어지는 구원의 은혜와 체험을 가리킵니다. 구체적으로 다음과 같은 것들입니다.</p>
<ul class="list-disc list-inside space-y-2">
<li>하나님의 사랑에 대한 확신</li>
<li>양심의 평안</li>
<li>성령 안에서의 기쁨</li>
<li>장차 올 영광에 대한 소망</li>
</ul>
<p>비록 이 경험이 때로는 미약할지라도, 성령의 내주 없이는 결코 나타날 수 없기에 장차 올 충만한 영광을 확실히 보증하는 증거가 됩니다. 이처럼 성도는 현재 하나님을 "아빠 아버지"라 부르며 자녀 됨의 영광을 미리 맛봅니다.</p>
</div>
</div>
<div>
<strong class="text-xl block text-gray-900">(2) 악인이 맛보는 심판의 시작</strong>
<div class="pl-4 mt-2 space-y-3 border-l-4 border-blue-100">
<p>성도가 하늘의 영광을 미리 맛보는 것과 대조적으로, 악인들은 이 세상에서부터 지옥의 고통을 미리 맛보기 시작합니다. 그들은 하나님의 진노를 느끼며, 그들의 <strong class="text-blue-600">양심</strong>이 그들을 고발하여 죄책감을 느끼게 합니다(롬 2:14-15). 악인의 양심은 평안 대신 하나님의 심판을 피할 수 없다는 공포와 다가오는 심판에 대한 두려움을 줍니다. 이것은 장차 그들이 당할 영원한 고통의 시작이며 예고편입니다. 그러나 이 심판의 첫 열매는 동시에 회개하고 그리스도께 나아오라는 하나님의 부르심이기도 합니다.</p>
</div>
</div>
</div>
</section>

<footer class="text-center mt-8 text-sm text-gray-500">
<p>교재는 날마다 양식으로 읽는 웨스트민스터 표준교리(영음사)를 사용합니다</p>
</footer>
</div>
<script>
        const tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        const firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

        let player;
        let progressInterval;
        const playPauseButton = document.getElementById('play-pause-button');
        const progressBar = document.getElementById('progress-bar');
        const errorMessageDiv = document.getElementById('error-message');
        const playerUi = document.getElementById('player-ui');

        function onYouTubeIframeAPIReady() {
            loadVideoForToday();
        }

        async function loadVideoForToday() {
            try {
                const response = await fetch('../address/dcaddr.txt');
                if (!response.ok) {
                    throw new Error('Audio address file could not be loaded.');
                }
                const data = await response.text();
                const lines = data.split('\n');
                
                const todayKey = '1030';

                // --- 수정된 부분 시작 ---
                // '1021'로 시작하는 줄을 찾습니다 (공백이나 '=' 모두 처리).
                const todayLine = lines.find(line => line.trim().startsWith(todayKey));
                
                if (!todayLine) {
                    throw new Error('not_uploaded');
                }

                // 날짜(키) 부분을 제외하고 나머지(URL)를 추출합니다.
                let url = todayLine.substring(todayKey.length).trim();
                // 맨 앞에 '=' 문자가 있다면 제거합니다.
                if (url.startsWith('=')) {
                    url = url.substring(1).trim();
                }
                // --- 수정된 부분 끝 ---

                const videoId = extractVideoID(url);

                if (!videoId) {
                    // URL은 찾았으나 비디오 ID 추출에 실패한 경우
                    throw new Error('Invalid YouTube URL in dcaddr.txt');
                }
                
                player = new YT.Player('player', {
                    height: '0',
                    width: '0',
                    videoId: videoId,
                    playerVars: {
                        'playsinline': 1
                    },
                    events: {
                        'onReady': onPlayerReady,
                        'onStateChange': onPlayerStateChange
                    }
                });

            } catch (error) {
                playerUi.classList.add('hidden');
                errorMessageDiv.classList.remove('hidden');
                if (error.message === 'not_uploaded') {
                    errorMessageDiv.textContent = '오늘의 AI요약 음성은 아직 업로드 전입니다.';
                } else {
                    errorMessageDiv.textContent = '오디오를 불러오는 중 오류가 발생했습니다.';
                    console.error('Error loading video:', error);
                }
            }
        }

        function extractVideoID(url) {
            // 다양한 YouTube URL 형식에서 비디오 ID를 추출하는 정규식
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
            const match = url.match(regExp);
            return (match && match[2].length === 11) ? match[2] : null;
        }

        function onPlayerReady(event) {
            playPauseButton.disabled = false;
            playPauseButton.textContent = '재생';
            playPauseButton.setAttribute('aria-label', '교리 오디오 재생');
            
            playPauseButton.addEventListener('click', togglePlayPause);
        }

        function onPlayerStateChange(event) {
            if (event.data === YT.PlayerState.PLAYING) {
                playPauseButton.textContent = '일시정지';
                playPauseButton.setAttribute('aria-label', '교리 오디오 일시정지');
                progressInterval = setInterval(updateProgressBar, 1000);
            } else {
                playPauseButton.textContent = '재생';
                playPauseButton.setAttribute('aria-label', '교리 오디오 재생');
                clearInterval(progressInterval);
                if (event.data === YT.PlayerState.ENDED) {
                    progressBar.style.width = '100%';
                }
            }
        }

        function togglePlayPause() {
            if (player.getPlayerState() === YT.PlayerState.PLAYING) {
                player.pauseVideo();
            } else {
                player.playVideo();
            }
        }

        function updateProgressBar() {
            if (player && player.getDuration) {
                const currentTime = player.getCurrentTime();
                const duration = player.getDuration();
                const progress = (currentTime / duration) * 100;
                progressBar.style.width = progress + '%';
            }
        }
    </script>
</body>
</html>
