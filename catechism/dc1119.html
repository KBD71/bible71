<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>11월 19일 | 세례의 요소와 시행</title>
    <link rel="stylesheet" as="style" crossorigin href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Pretendard', sans-serif;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto max-w-4xl px-4 py-8">

        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-900">11월 19일</h1>
            <p class="text-xl text-gray-600 mt-2">세례의 요소와 시행</p>
        </header>

        <section id="audio-player-section" class="bg-white p-6 rounded-lg shadow-md mb-6">
            <h2 class="text-2xl font-semibold mb-4">AI요약 듣기</h2>
            <div id="player-ui" class="flex items-center space-x-4">
                <button id="play-pause-button" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-full w-28 transition-opacity duration-300" aria-label="교리 오디오 재생/일시정지" disabled>
                    로딩 중...
                </button>
                <div class="w-full bg-gray-200 rounded-full h-2.5">
                    <div id="progress-bar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
                </div>
            </div>
            <div id="player" class="hidden"></div>
            <div id="error-message" class="hidden text-red-500 mt-4"></div>
            <p class="mt-4 text-sm text-gray-500">
                오늘의 자료는 유튜브 영상입니다. '재생' 버튼을 누르면 영상의 음성이 재생됩니다.<br>
                영상 URL: <a href="https://www.youtube.com/watch?v=fKpf3e6PwdE" target="_blank" class="text-blue-600 hover:underline">https://www.youtube.com/watch?v=fKpf3e6PwdE</a>
            </p>
        </section>
        
        <section class="bg-white p-6 rounded-lg shadow-md mb-6">
            <h2 class="text-2xl font-semibold mb-4 text-blue-800">신앙고백서 28.2 (주제)</h2>
            <div class="space-y-4 text-lg leading-relaxed">
                <p><strong class="font-bold">문:</strong> 세례에 사용되는 외적 요소는 무엇이며, 이는 무엇을 의미합니까?</p>
                <p><strong class="font-bold">답:</strong> 세례의 외적 요소는 <strong class="text-blue-600">물</strong>입니다. 이는 예수 그리스도께서 친히 명령하신 것으로, 물 외의 다른 요소(기름, 우유, 포도주 등)는 사용될 수 없습니다. 물은 죄를 씻어 정결하게 하는 <strong class="text-blue-600">정화(cleansing)</strong>의 은혜를 상징하는 외적인 표지입니다.</p>
            </div>
        </section>

        <section class="bg-white p-6 rounded-lg shadow-md mb-6">
            <h2 class="text-2xl font-semibold mb-4 text-blue-800">교리 해설</h2>
            <div class="space-y-4 text-lg leading-relaxed">
                <p>
                    기독교 세례의 핵심 요소는 <strong class="text-blue-600">‘물’</strong>입니다. 너무나 당연해 보이는 이 사실을 웨스트민스터 신앙고백서가 굳이 명시한 이유는 역사적인 배경과 깊은 신학적 의미가 있기 때문입니다.
                </p>
                <p>
                    물은 <strong class="text-blue-600">‘외적 요소’</strong>로서, 눈에 보이지 않는 내적인 영적 은혜(죄 사함, 거듭남)를 눈에 보이는 방식으로 나타내는 표지입니다. 그러나 역사 속에서 영지주의자들과 같은 이단들은 물질 세계를 악하거나 열등하게 여겼습니다. 그들은 "어떻게 순수한 영이신 하나님이 물처럼 평범하고 저급한 물질을 통해 은혜를 주시겠는가?"라고 생각하며, 물 대신 더 '영적'이라고 여겨지는 대체물들(신비한 능력을 상징하는 기름, 순수함을 상징하는 우유, 생명력을 상징하는 포도주 등)을 사용하려 했습니다.
                </p>
                <p>
                    그러나 신앙고백서는 이를 단호히 거부합니다. 그 이유는 두 가지입니다.
                </p>
                <ul class="list-disc list-inside space-y-4 pl-4">
                    <li>
                        <strong class="text-blue-600">그리스도의 명령에 대한 순종:</strong> 예수님께서는 마태복음 28장에서 분명히 물로 세례를 주라고 명령하셨습니다. 물 이외의 것을 사용하는 것은 주님의 명령을 정면으로 어기는 것입니다.
                    </li>
                    <li>
                        <strong class="text-blue-600">핵심 상징의 보존:</strong> 세례의 본질적인 의미는 '죄를 씻어 정결하게 함'입니다. 물만이 이 <strong class="text-blue-600">씻음(washing)</strong>과 <strong class="text-blue-600">정화(purification)</strong>의 상징을 가장 완벽하고 보편적으로 담아낼 수 있습니다.
                    </li>
                </ul>
                <p>
                    따라서 오직 물만이 그리스도께서 제정하신 유일하게 올바른 세례의 요소이며, 다른 물질로 베푼 세례는 효력이 없습니다. 이는 우리가 하나님께서 정하신 단순하고 구체적인 방식에 순종하는 것이 얼마나 중요한지를 보여줍니다.
                </p>
            </div>
        </section>

        <section class="bg-white p-6 rounded-lg shadow-md">
            <h2 class="text-2xl font-semibold mb-4 text-blue-800">적용 질문</h2>
            <div class="space-y-4 text-lg leading-relaxed">
                <p>끊임없이 뭔가 새로운 것, 더 깊고 복잡해 보이는 상징적 의미를 찾아 헤매는 현대 사회 속에서, 세례의 요소로서 지극히 단순하고 물리적인 '물'을 고수해야 한다는 이 강조점은 당신에게 어떤 의미로 다가옵니까? 이것이 당신의 신앙생활이나 종교 의식, 그리고 하나님의 명령에 대한 순종의 자세를 어떻게 돌아보게 만드나요?</p>
            </div>
        </section>

        <footer class="text-center mt-8 text-sm text-gray-500">
            <p>교재는 날마다 양식으로 읽는 웨스트민스터 표준교리(영음사)를 사용합니다</p>
        </footer>

    </div>

    <script>
        const tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        const firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

        let player;
        let progressInterval;
        const playPauseButton = document.getElementById('play-pause-button');
        const progressBar = document.getElementById('progress-bar');
        const errorMessageDiv = document.getElementById('error-message');
        const playerUi = document.getElementById('player-ui');
        
        // 11월 19일 자료는 제공된 유튜브 링크 ID를 직접 사용합니다.
        const videoIdForToday = 'fKpf3e6PwdE';

        function onYouTubeIframeAPIReady() {
            // txt 파일 로드 대신 직접 ID로 플레이어 생성
            try {
                if (!videoIdForToday) {
                    throw new Error('No video ID specified.');
                }
                
                player = new YT.Player('player', {
                    height: '0',
                    width: '0',
                    videoId: videoIdForToday,
                    playerVars: {
                        'playsinline': 1
                    },
                    events: {
                        'onReady': onPlayerReady,
                        'onStateChange': onPlayerStateChange
                    }
                });

            } catch (error) {
                playerUi.classList.add('hidden');
                errorMessageDiv.classList.remove('hidden');
                errorMessageDiv.textContent = '오디오를 불러오는 중 오류가 발생했습니다.';
                console.error('Error creating player:', error);
            }
        }

        // dcaddr.txt 파일을 로드하는 함수 (참고용으로 남겨둠)
        async function loadVideoForToday_fromFile() {
            try {
                const response = await fetch('../address/dcaddr.txt');
                if (!response.ok) {
                    throw new Error('Audio address file could not be loaded.');
                }
                const data = await response.text();
                const lines = data.split('\n');
                
                const todayKey = '1119'; // 키는 1119로 설정

                // '1119'로 시작하는 줄을 찾습니다 (공백이나 '=' 모두 처리).
                const todayLine = lines.find(line => line.trim().startsWith(todayKey));
                
                if (!todayLine) {
                    throw new Error('not_uploaded');
                }

                // 날짜(키) 부분을 제외하고 나머지(URL)를 추출합니다.
                let url = todayLine.substring(todayKey.length).trim();
                // 맨 앞에 '=' 문자가 있다면 제거합니다.
                if (url.startsWith('=')) {
                    url = url.substring(1).trim();
                }

                const videoId = extractVideoID(url);

                if (!videoId) {
                    throw new Error('Invalid YouTube URL in dcaddr.txt');
                }
                
                player = new YT.Player('player', {
                    height: '0',
                    width: '0',
                    videoId: videoId,
                    playerVars: {
                        'playsinline': 1
                    },
                    events: {
                        'onReady': onPlayerReady,
                        'onStateChange': onPlayerStateChange
                    }
                });

            } catch (error) {
                playerUi.classList.add('hidden');
                errorMessageDiv.classList.remove('hidden');
                if (error.message === 'not_uploaded') {
                    errorMessageDiv.textContent = '오늘의 AI요약 음성은 아직 업로드 전입니다.';
                } else {
                    errorMessageDiv.textContent = '오디오를 불러오는 중 오류가 발생했습니다.';
                    console.error('Error loading video:', error);
                }
            }
        }

        function extractVideoID(url) {
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
            const match = url.match(regExp);
            return (match && match[2].length === 11) ? match[2] : null;
        }

        function onPlayerReady(event) {
            playPauseButton.disabled = false;
            playPauseButton.textContent = '재생';
            playPauseButton.setAttribute('aria-label', '교리 오디오 재생');
            
            playPauseButton.addEventListener('click', togglePlayPause);
        }

        function onPlayerStateChange(event) {
            if (event.data === YT.PlayerState.PLAYING) {
                playPauseButton.textContent = '일시정지';
                playPauseButton.setAttribute('aria-label', '교리 오디오 일시정지');
                progressInterval = setInterval(updateProgressBar, 1000);
            } else {
                playPauseButton.textContent = '재생';
                playPauseButton.setAttribute('aria-label', '교리 오디오 재생');
                clearInterval(progressInterval);
                if (event.data === YT.PlayerState.ENDED) {
                    progressBar.style.width = '100%';
                }
            }
        }

        function togglePlayPause() {
            if (player.getPlayerState() === YT.PlayerState.PLAYING) {
                player.pauseVideo();
            } else {
                player.playVideo();
            }
        }

        function updateProgressBar() {
            if (player && player.getDuration) {
                const currentTime = player.getCurrentTime();
                const duration = player.getDuration();
                const progress = (currentTime / duration) * 100;
                progressBar.style.width = progress + '%';
            }
        }
    </script>

</body>
</html>
