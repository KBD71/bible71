<!DOCTYPE html>

<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>10월 22일 | 보이는 교회와 구원</title>
<link as="style" crossorigin="" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css" rel="stylesheet"/>
<script src="https://cdn.tailwindcss.com"></script>
<style>
        body {
            font-family: 'Pretendard', sans-serif;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">
<div class="container mx-auto max-w-3xl px-4 py-8">
<header class="text-center mb-8">
<h1 class="text-4xl font-bold text-gray-900">10월 22일</h1>
<p class="text-xl text-gray-600 mt-2">보이는 교회와 구원</p>
</header>
<section class="bg-white p-6 rounded-lg shadow-md mb-6" id="audio-player-section">
<h2 class="text-2xl font-semibold mb-4">AI요약 듣기</h2>
<div class="flex items-center space-x-4" id="player-ui">
<button aria-label="교리 오디오 재생/일시정지" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-full w-28 transition-opacity duration-300" disabled="" id="play-pause-button">
                    로딩 중...
                </button>
<div class="w-full bg-gray-200 rounded-full h-2.5">
<div class="bg-blue-600 h-2.5 rounded-full" id="progress-bar" style="width: 0%"></div>
</div>
</div>
<div class="hidden" id="player"></div>
<div class="hidden text-red-500 mt-4" id="error-message"></div>
</section>
<section class="bg-white p-6 rounded-lg shadow-md mb-6">
<h2 class="text-2xl font-semibold mb-4 text-blue-800">대요리문답 61</h2>
<div class="space-y-4 text-lg leading-relaxed">
<p><strong class="font-bold">문:</strong> 복음을 듣고 교회 안에서 생활하는 사람들은 다 구원받습니까?</p>
<p><strong class="font-bold">답:</strong> 복음을 듣고 보이는 교회 안에서 생활하는 사람들이 다 구원받을 수 있는 것은 아닙니다. 다만 보이지 않는 교회의 참된 지체들만이 구원받습니다.</p>
</div>
</section>
<section class="bg-white p-6 rounded-lg shadow-md mb-6">
<h2 class="text-2xl font-semibold mb-4 text-blue-800">교리 해설</h2>
<div class="space-y-4 text-lg leading-relaxed">
<p>
                    대요리문답 61항은 복음을 듣고 교회에서 생활하는 것만으로 구원이 보장된다는 흔한 오해에 대해 명확히 답합니다. 결론은 '아니오'입니다. 외적으로는 <strong class="text-blue-600">‘보이는 교회’</strong>에 성실히 참여하더라도, 내적으로 복음에 합당한 참된 믿음이 없을 수 있기 때문입니다. 이는 소위 <strong class="text-blue-600">‘명목상 그리스도인’</strong>, 즉 이름만 신자인 이들이 헛된 구원의 확신에 빠지는 것을 경고합니다.
                </p>
<ul class="list-none space-y-4">
<li>
<strong class="text-xl block text-gray-900">(1) “복음을 듣고 보이는 교회 안에서 생활하는 사람들이 다 구원받을 수 있는 것은 아닙니다”</strong>
<div class="pl-4 mt-2 space-y-2 border-l-4 border-blue-100">
<p>여기서 '복음을 듣는 것'은 단순히 귀로 들어 그 내용을 지식으로 아는 데 그치는 경우를 의미합니다. 구원을 주는 믿음은 성령과 말씀이 마음속에 일으키시는 '구원의 은혜'입니다. 이 은혜는 자신의 죄와 비참함을 깨닫고, 오직 그리스도와 그분의 의를 의지하게 하는 근본적인 변화를 동반합니다. 이러한 변화 없이 듣기만 하는 것은 충분하지 않습니다.</p>
<p>또한 '보이는 교회 안에서 생활한다'는 것은 교회의 여러 활동에 참여하는 것을 말합니다. 하지만 성경은 <strong class="text-blue-600">‘보이는 교회’</strong> 안에 하나님께 속하지 않은 자들이 섞여 있음을 분명히 합니다(요일 2:19). 광야 시대 이스라엘 백성은 세례를 받고 신령한 음식을 먹는 등 교회의 특권을 누렸으나, 참된 믿음이 없었기에 다수가 멸망했습니다(고전 10:1-5). 이처럼 외적인 참여가 구원을 보증하지는 않습니다.</p>
</div>
</li>
<li>
<strong class="text-xl block text-gray-900">(2) “다만 보이지 않는 교회의 참된 지체들만이 구원받습니다”</strong>
<div class="pl-4 mt-2 space-y-2 border-l-4 border-blue-100">
<p>대요리문답은 구원받는 자는 오직 <strong class="text-blue-600">‘보이지 않는 교회’</strong>의 참된 지체들뿐이라고 단언합니다. 이는 그리스도께서 알곡과 가라지, 좋은 물고기와 나쁜 물고기가 섞여 있다고 말씀하신 비유와 일치합니다(마 13장). 이 가르침의 목적은 두려움을 조장하는 것이 아닙니다. 오히려 명목상 신자에게는 자신을 돌아보라는 경고를, 교회 내 위선자들로 인해 낙심하는 참 신자들에게는 보호와 위로를, 그리고 하나님의 택한 백성에게는 구원이 결코 취소되지 않는다는 확신과 안도감을 주기 위함입니다.</p>
</div>
</li>
</ul>
</div>
</section>

<footer class="text-center mt-8 text-sm text-gray-500">
<p>교재는 날마다 양식으로 읽는 웨스트민스터 표준교리(영음사)를 사용합니다</p>
</footer>
</div>
<script>
        const tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        const firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

        let player;
        let progressInterval;
        const playPauseButton = document.getElementById('play-pause-button');
        const progressBar = document.getElementById('progress-bar');
        const errorMessageDiv = document.getElementById('error-message');
        const playerUi = document.getElementById('player-ui');

        function onYouTubeIframeAPIReady() {
            loadVideoForToday();
        }

        async function loadVideoForToday() {
            try {
                const response = await fetch('../address/dcaddr.txt');
                if (!response.ok) {
                    throw new Error('Audio address file could not be loaded.');
                }
                const data = await response.text();
                const lines = data.split('\n');
                
                const todayKey = '1022';

                // --- 수정된 부분 시작 ---
                // '1021'로 시작하는 줄을 찾습니다 (공백이나 '=' 모두 처리).
                const todayLine = lines.find(line => line.trim().startsWith(todayKey));
                
                if (!todayLine) {
                    throw new Error('not_uploaded');
                }

                // 날짜(키) 부분을 제외하고 나머지(URL)를 추출합니다.
                let url = todayLine.substring(todayKey.length).trim();
                // 맨 앞에 '=' 문자가 있다면 제거합니다.
                if (url.startsWith('=')) {
                    url = url.substring(1).trim();
                }
                // --- 수정된 부분 끝 ---

                const videoId = extractVideoID(url);

                if (!videoId) {
                    // URL은 찾았으나 비디오 ID 추출에 실패한 경우
                    throw new Error('Invalid YouTube URL in dcaddr.txt');
                }
                
                player = new YT.Player('player', {
                    height: '0',
                    width: '0',
                    videoId: videoId,
                    playerVars: {
                        'playsinline': 1
                    },
                    events: {
                        'onReady': onPlayerReady,
                        'onStateChange': onPlayerStateChange
                    }
                });

            } catch (error) {
                playerUi.classList.add('hidden');
                errorMessageDiv.classList.remove('hidden');
                if (error.message === 'not_uploaded') {
                    errorMessageDiv.textContent = '오늘의 AI요약 음성은 아직 업로드 전입니다.';
                } else {
                    errorMessageDiv.textContent = '오디오를 불러오는 중 오류가 발생했습니다.';
                    console.error('Error loading video:', error);
                }
            }
        }

        function extractVideoID(url) {
            // 다양한 YouTube URL 형식에서 비디오 ID를 추출하는 정규식
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
            const match = url.match(regExp);
            return (match && match[2].length === 11) ? match[2] : null;
        }

        function onPlayerReady(event) {
            playPauseButton.disabled = false;
            playPauseButton.textContent = '재생';
            playPauseButton.setAttribute('aria-label', '교리 오디오 재생');
            
            playPauseButton.addEventListener('click', togglePlayPause);
        }

        function onPlayerStateChange(event) {
            if (event.data === YT.PlayerState.PLAYING) {
                playPauseButton.textContent = '일시정지';
                playPauseButton.setAttribute('aria-label', '교리 오디오 일시정지');
                progressInterval = setInterval(updateProgressBar, 1000);
            } else {
                playPauseButton.textContent = '재생';
                playPauseButton.setAttribute('aria-label', '교리 오디오 재생');
                clearInterval(progressInterval);
                if (event.data === YT.PlayerState.ENDED) {
                    progressBar.style.width = '100%';
                }
            }
        }

        function togglePlayPause() {
            if (player.getPlayerState() === YT.PlayerState.PLAYING) {
                player.pauseVideo();
            } else {
                player.playVideo();
            }
        }

        function updateProgressBar() {
            if (player && player.getDuration) {
                const currentTime = player.getCurrentTime();
                const duration = player.getDuration();
                const progress = (currentTime / duration) * 100;
                progressBar.style.width = progress + '%';
            }
        }
    </script>
</body>
</html>
