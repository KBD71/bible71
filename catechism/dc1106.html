<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>11월 6일 | 하나님의 말씀의 설교자</title>
    <link rel="stylesheet" as="style" crossorigin href="[https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css](https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css)" />
    <script src="[https://cdn.tailwindcss.com](https://cdn.tailwindcss.com)"></script>
    <style>
        body {
            font-family: 'Pretendard', sans-serif;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto max-w-4xl px-4 py-8">

        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-900">11월 6일</h1>
            <p class="text-xl text-gray-600 mt-2">하나님의 말씀의 설교자</p>
        </header>

        <section id="audio-player-section" class="bg-white p-6 rounded-lg shadow-md mb-6">
            <h2 class="text-2xl font-semibold mb-4">AI요약 듣기</h2>
            <div id="player-ui" class="flex items-center space-x-4">
                <button id="play-pause-button" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-full w-28 transition-opacity duration-300" aria-label="교리 오디오 재생/일시정지" disabled>
                    로딩 중...
                </button>
                <div class="w-full bg-gray-200 rounded-full h-2.5">
                    <div id="progress-bar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
                </div>
            </div>
            <div id="player" class="hidden"></div>
            <div id="error-message" class="hidden text-red-500 mt-4"></div>
            <p class="mt-4 text-sm text-gray-500">
                오늘의 자료는 유튜브 영상입니다. '재생' 버튼을 누르면 영상의 음성이 재생됩니다.<br>
                영상 URL: <a href="[https://www.youtube.com/watch?v=ss9HANrI1Kw](https://www.youtube.com/watch?v=ss9HANrI1Kw)" target="_blank" class="text-blue-600 hover:underline">[https://www.youtube.com/watch?v=ss9HANrI1Kw](https://www.youtube.com/watch?v=ss9HANrI1Kw)</a>
            </p>
        </section>
        
        <section class="bg-white p-6 rounded-lg shadow-md mb-6">
            <h2 class="text-2xl font-semibold mb-4 text-blue-800">대요리문답 158문</h2>
            <div class="space-y-4 text-lg leading-relaxed">
                <p><strong class="font-bold">문:</strong> 하나님의 말씀은 누가 설교할 수 있습니까?</p>
                <p><strong class="font-bold">답:</strong> 충분한 은사를 받았을뿐만 아니라 그 직무를 감당하도록 공식적으로 인허받고 부름을 받은 사람만이 설교할 수 있습니다.</p>
            </div>
        </section>

        <section class="bg-white p-6 rounded-lg shadow-md mb-6">
            <h2 class="text-2xl font-semibold mb-4 text-blue-800">교리 해설</h2>
            <div class="space-y-4 text-lg leading-relaxed">
                <p>
                    웨스트민스터 대요리문답 158문은 "하나님의 말씀을 누가 설교할 자격이 있는가?"라는 중요한 질문을 다룹니다. 이 교리는 설교를 단순한 개인의 생각 발표나 강의가 아니라, 공적인 예배에서 하나님의 말씀을 대언하는 거룩한 직무로 규정합니다. 따라서 아무나 할 수 있는 일이 아니며, 설교자를 통해 말씀하시는 분은 하나님이라는 엄격한 전제를 가지고 있습니다.
                </p>
                <p>
                    이 직무를 감당하기 위해서는 세 가지 핵심 조건이 필요합니다.
                </p>
                <ul class="list-disc list-inside space-y-4 pl-4">
                    <li>
                        <strong class="text-blue-600">충분한 은사:</strong>
                        여기에는 성경 해석 능력이나 가르치는 능력과 같은 실력적인 측면과, 본이 되는 삶과 온유함 같은 인품이 모두 포함됩니다. 이 '은사'는 세상적인 재능, 대중적 인기, SNS 팔로워 수와는 구별되는, 성령께서 주시는 영적인 자질을 의미합니다.
                    </li>
                    <li>
                        <strong class="text-blue-600">공식적인 인허:</strong>
                        개인이 스스로 자격이 있다고 판단하거나 주변 사람들이 인정하는 것만으로는 부족합니다. 반드시 교회의 공식적인 권위(노회, 총회 등)를 통해 심사를 받고 안수받는 공식적인 절차를 거쳐야 합니다. 이는 말씀을 왜곡할 위험을 막고 교회의 공적 질서를 유지하기 위한 장치입니다.
                    </li>
                    <li>
                        <strong class="text-blue-600">부름을 받음 (소명):</strong>
                        이는 설교 직무가 단순한 직업 선택이나 개인의 야망 실현과 다름을 보여주는 핵심입니다. 외적인 은사와 교회의 인정(외적인 부르심)뿐만 아니라, 마음 깊은 곳에서부터 오는 <strong class="text-blue-600">내적인 부르심(소명)</strong>이 반드시 있어야 합니다. 이는 성령께서 주시는 강렬한 사명감과 하나님의 나라를 위한 진실한 헌신의 소원을 의미합니다.
                    </li>
                </ul>
                <p>
                    결론적으로, 설교는 하나님의 부르심(소명), 성령의 특별한 은사, 그리고 교회의 공적인 인정이라는 세 가지 요소를 모두 갖춘 사람만이 수행할 수 있는 거룩하고 공적인 직무입니다.
                </p>
            </div>
        </section>

        <section class="bg-white p-6 rounded-lg shadow-md">
            <h2 class="text-2xl font-semibold mb-4 text-blue-800">적용 질문</h2>
            <div class="space-y-4 text-lg leading-relaxed">
                <p>요즘처럼 정말 누구나 쉽게 목소리를 내고 또 정보를 퍼트릴 수 있는 시대잖아요. 이런 시대에 이렇게 설교자의 자격과 권위를 엄격하게 규정하는이 전통적인 관점을 딱 접하고 나니 좀 어떤 생각이 드시는지요? 여러분께서 매일매일 접하시는 그 수많은 메시지들 있잖아요, 그게 뭐 종교적인 내용이든 아니든 간에요. 그 메시지의 신뢰성이나 권위를 여러분은 보통 어떤 기준으로 판단하고 계신가요?</p>
            </div>
        </section>

        <footer class="text-center mt-8 text-sm text-gray-500">
            <p>교재는 날마다 양식으로 읽는 웨스트민스터 표준교리(영음사)를 사용합니다</p>
        </footer>

    </div>

    <script>
        const tag = document.createElement('script');
        tag.src = "[https://www.youtube.com/iframe_api](https://www.youtube.com/iframe_api)";
        const firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

        let player;
        let progressInterval;
        const playPauseButton = document.getElementById('play-pause-button');
        const progressBar = document.getElementById('progress-bar');
        const errorMessageDiv = document.getElementById('error-message');
        const playerUi = document.getElementById('player-ui');
        
        // 11월 6일 자료는 제공된 유튜브 링크 ID를 직접 사용합니다.
        const videoIdForToday = 'ss9HANrI1Kw';

        function onYouTubeIframeAPIReady() {
            // txt 파일 로드 대신 직접 ID로 플레이어 생성
            try {
                if (!videoIdForToday) {
                    throw new Error('No video ID specified.');
                }
                
                player = new YT.Player('player', {
                    height: '0',
                    width: '0',
                    videoId: videoIdForToday,
                    playerVars: {
                        'playsinline': 1
                    },
                    events: {
                        'onReady': onPlayerReady,
                        'onStateChange': onPlayerStateChange
                    }
                });

            } catch (error) {
                playerUi.classList.add('hidden');
                errorMessageDiv.classList.remove('hidden');
                errorMessageDiv.textContent = '오디오를 불러오는 중 오류가 발생했습니다.';
                console.error('Error creating player:', error);
            }
        }

        // dcaddr.txt 파일을 로드하는 함수 (참고용으로 남겨둠)
        async function loadVideoForToday_fromFile() {
            try {
                const response = await fetch('../address/dcaddr.txt');
                if (!response.ok) {
                    throw new Error('Audio address file could not be loaded.');
                }
                const data = await response.text();
                const lines = data.split('\n');
                
                const todayKey = '1106'; // 키는 1106로 설정

                // '1106'로 시작하는 줄을 찾습니다 (공백이나 '=' 모두 처리).
                const todayLine = lines.find(line => line.trim().startsWith(todayKey));
                
                if (!todayLine) {
                    throw new Error('not_uploaded');
                }

                // 날짜(키) 부분을 제외하고 나머지(URL)를 추출합니다.
                let url = todayLine.substring(todayKey.length).trim();
                // 맨 앞에 '=' 문자가 있다면 제거합니다.
                if (url.startsWith('=')) {
                    url = url.substring(1).trim();
                }

                const videoId = extractVideoID(url);

                if (!videoId) {
                    throw new Error('Invalid YouTube URL in dcaddr.txt');
                }
                
                player = new YT.Player('player', {
                    height: '0',
                    width: '0',
                    videoId: videoId,
                    playerVars: {
                        'playsinline': 1
                    },
                    events: {
                        'onReady': onPlayerReady,
                        'onStateChange': onPlayerStateChange
                    }
                });

            } catch (error) {
                playerUi.classList.add('hidden');
                errorMessageDiv.classList.remove('hidden');
                if (error.message === 'not_uploaded') {
                    errorMessageDiv.textContent = '오늘의 AI요약 음성은 아직 업로드 전입니다.';
                } else {
                    errorMessageDiv.textContent = '오디오를 불러오는 중 오류가 발생했습니다.';
                    console.error('Error loading video:', error);
                }
            }
        }

        function extractVideoID(url) {
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
            const match = url.match(regFilegExp);
            return (match && match[2].length === 11) ? match[2] : null;
        }

        function onPlayerReady(event) {
            playPauseButton.disabled = false;
            playPauseButton.textContent = '재생';
            playPauseButton.setAttribute('aria-label', '교리 오디오 재생');
            
            playPauseButton.addEventListener('click', togglePlayPause);
        }

        function onPlayerStateChange(event) {
            if (event.data === YT.PlayerState.PLAYING) {
                playPauseButton.textContent = '일시정지';
                playPauseButton.setAttribute('aria-label', '교리 오디오 일시정지');
                progressInterval = setInterval(updateProgressBar, 1000);
            } else {
                playPauseButton.textContent = '재생';
                playPauseButton.setAttribute('aria-label', '교리 오디오 재생');
                clearInterval(progressInterval);
                if (event.data === YT.PlayerState.ENDED) {
                    progressBar.style.width = '100%';
                }
            }
        }

        function togglePlayPause() {
            if (player.getPlayerState() === YT.PlayerState.PLAYING) {
                player.pauseVideo();
            } else {
                player.playVideo();
            }
        }

        function updateProgressBar() {
            if (player && player.getDuration) {
                const currentTime = player.getCurrentTime();
                const duration = player.getDuration();
                const progress = (currentTime / duration) * 100;
                progressBar.style.width = progress + '%';
            }
        }
    </script>

</body>
</html>
