<!DOCTYPE html>

<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>10월 25일 | 교회의 머리</title>
<link as="style" crossorigin="" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css" rel="stylesheet"/>
<script src="https://cdn.tailwindcss.com"></script>
<style>
        body {
            font-family: 'Pretendard', sans-serif;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">
<div class="container mx-auto max-w-3xl px-4 py-8">
<header class="text-center mb-8">
<h1 class="text-4xl font-bold text-gray-900">10월 25일</h1>
<p class="text-xl text-gray-600 mt-2">교회의 머리</p>
</header>
<section class="bg-white p-6 rounded-lg shadow-md mb-6" id="audio-player-section">
<h2 class="text-2xl font-semibold mb-4">AI요약 듣기</h2>
<div class="flex items-center space-x-4" id="player-ui">
<button aria-label="교리 오디오 재생/일시정지" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-full w-28 transition-opacity duration-300" disabled="" id="play-pause-button">
                    로딩 중...
                </button>
<div class="w-full bg-gray-200 rounded-full h-2.5">
<div class="bg-blue-600 h-2.5 rounded-full" id="progress-bar" style="width: 0%"></div>
</div>
</div>
<div class="hidden" id="player"></div>
<div class="hidden text-red-500 mt-4" id="error-message"></div>
</section>
<section class="bg-white p-6 rounded-lg shadow-md mb-6">
<h2 class="text-2xl font-semibold mb-4 text-blue-800">신앙고백서 25.6</h2>
<div class="space-y-4 text-lg leading-relaxed">
<p>주 예수 그리스도 외에 교회의 다른 머리는 없다. 로마 교황은 어떤 의미에서도 교회의 머리일 수 없다. 오히려 그는 그리스도를 대적하고 하나님으로 불리는 모든 것에 대적하여 교회에서 자신을 높이는 적그리스도이며, 불법의 사람이고, 멸망의 아들이다.</p>
</div>
</section>
<section class="bg-white p-6 rounded-lg shadow-md mb-6">
<h2 class="text-2xl font-semibold mb-4 text-blue-800">교리 해설</h2>
<div class="space-y-6 text-lg leading-relaxed">
<p>
                    신앙고백서 25.6은 교황을 교회의 머리로 인정하는 로마 가톨릭의 주장을 정면으로 배격하며, 교회의 머리는 오직 그리스도뿐임을 확고히 합니다.
                </p>
<div>
<strong class="text-xl block text-gray-900">(1) 주 예수 그리스도 외에 교회의 다른 머리는 없다</strong>
<div class="pl-4 mt-2 space-y-3 border-l-4 border-blue-100">
<p>성경이 증언하듯(엡 1:22; 골 1:18), <strong class="text-blue-600">교회의 머리</strong>는 오직 그리스도 한 분뿐입니다. 이 고백은 그리스도께서 단순히 조직의 최상위에 계시다는 의미를 넘어, 그분만이 자신의 몸인 교회에 생명과 능력을 주시고 자신의 뜻대로 다스리시는 분임을 뜻합니다. 몸이 머리에 유기적으로 연합되어 있듯이, 교회는 그리스도로부터 생명과 은혜를 공급받으며 그분을 떠나서는 존재할 수 없습니다. 교회가 아무리 연약하고 오류가 많을지라도, 머리이신 그리스도께서는 자신의 몸인 교회를 끝까지 돌보시고 영광으로 인도하십니다.</p>
</div>
</div>
<div>
<strong class="text-xl block text-gray-900">(2) 로마 교황은 어떤 의미에서도 교회의 머리일 수 없다</strong>
<div class="pl-4 mt-2 space-y-3 border-l-4 border-blue-100">
<p>로마 가톨릭은 그리스도를 '보이지 않는 머리', 교황을 '보이는 머리'라고 주장합니다. 그러나 신앙고백서는 교황이 "어떤 의미에서도" 교회의 머리가 될 수 없다고 못 박음으로써, 이러한 주장이 그리스도의 머리 되심을 찬탈하는 행위임을 분명히 합니다. 교회의 참됨은 교황과의 연결이 아니라, 말씀, 성례, 권징의 바른 시행을 통해 드러나는 그리스도와의 연합에 달려 있습니다.</p>
</div>
</div>
<div>
<strong class="text-xl block text-gray-900">(3) 교황은 적그리스도이며, 불법의 사람이고, 멸망의 아들이다</strong>
<div class="pl-4 mt-2 space-y-3 border-l-4 border-blue-100">
<p>교황이 '그리스도의 대리자'라는 이름으로 그리스도의 권위를 차지하는 것은 단순한 제도의 오류를 넘어선 심각한 죄악입니다. 이 때문에 종교개혁자들과 웨스트민스터 총회는 데살로니가후서 2:3-4에 근거하여 교황을 <strong class="text-blue-600">“적그리스도”</strong>(Antichrist), <strong class="text-blue-600">“불법의 사람”</strong>, <strong class="text-blue-600">“멸망의 아들”</strong>로 규정했습니다. 이는 교황주의가 그리스도를 대적하고 스스로를 신격화하는 본질을 가졌음을 선언한 것입니다.</p>
<p>참고로, 미국 장로교회는 1789년에 신생 국가의 사회적 통합을 고려하여 이 문구를 삭제했습니다. 그러나 신앙고백서는 정치적 문서가 아니므로, 종교개혁 신학의 연속성을 지키기 위해 원문을 복원하는 것이 교회의 정체성을 지키는 데 유익하다는 견해가 있습니다.</p>
</div>
</div>
</div>
</section>

<footer class="text-center mt-8 text-sm text-gray-500">
<p>교재는 날마다 양식으로 읽는 웨스트민스터 표준교리(영음사)를 사용합니다</p>
</footer>
</div>
<script>
        const tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        const firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

        let player;
        let progressInterval;
        const playPauseButton = document.getElementById('play-pause-button');
        const progressBar = document.getElementById('progress-bar');
        const errorMessageDiv = document.getElementById('error-message');
        const playerUi = document.getElementById('player-ui');

        function onYouTubeIframeAPIReady() {
            loadVideoForToday();
        }

        async function loadVideoForToday() {
            try {
                const response = await fetch('../address/dcaddr.txt');
                if (!response.ok) {
                    throw new Error('Audio address file could not be loaded.');
                }
                const data = await response.text();
                const lines = data.split('\n');
                
                const todayKey = '1025';

                // --- 수정된 부분 시작 ---
                // '1021'로 시작하는 줄을 찾습니다 (공백이나 '=' 모두 처리).
                const todayLine = lines.find(line => line.trim().startsWith(todayKey));
                
                if (!todayLine) {
                    throw new Error('not_uploaded');
                }

                // 날짜(키) 부분을 제외하고 나머지(URL)를 추출합니다.
                let url = todayLine.substring(todayKey.length).trim();
                // 맨 앞에 '=' 문자가 있다면 제거합니다.
                if (url.startsWith('=')) {
                    url = url.substring(1).trim();
                }
                // --- 수정된 부분 끝 ---

                const videoId = extractVideoID(url);

                if (!videoId) {
                    // URL은 찾았으나 비디오 ID 추출에 실패한 경우
                    throw new Error('Invalid YouTube URL in dcaddr.txt');
                }
                
                player = new YT.Player('player', {
                    height: '0',
                    width: '0',
                    videoId: videoId,
                    playerVars: {
                        'playsinline': 1
                    },
                    events: {
                        'onReady': onPlayerReady,
                        'onStateChange': onPlayerStateChange
                    }
                });

            } catch (error) {
                playerUi.classList.add('hidden');
                errorMessageDiv.classList.remove('hidden');
                if (error.message === 'not_uploaded') {
                    errorMessageDiv.textContent = '오늘의 AI요약 음성은 아직 업로드 전입니다.';
                } else {
                    errorMessageDiv.textContent = '오디오를 불러오는 중 오류가 발생했습니다.';
                    console.error('Error loading video:', error);
                }
            }
        }

        function extractVideoID(url) {
            // 다양한 YouTube URL 형식에서 비디오 ID를 추출하는 정규식
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
            const match = url.match(regExp);
            return (match && match[2].length === 11) ? match[2] : null;
        }

        function onPlayerReady(event) {
            playPauseButton.disabled = false;
            playPauseButton.textContent = '재생';
            playPauseButton.setAttribute('aria-label', '교리 오디오 재생');
            
            playPauseButton.addEventListener('click', togglePlayPause);
        }

        function onPlayerStateChange(event) {
            if (event.data === YT.PlayerState.PLAYING) {
                playPauseButton.textContent = '일시정지';
                playPauseButton.setAttribute('aria-label', '교리 오디오 일시정지');
                progressInterval = setInterval(updateProgressBar, 1000);
            } else {
                playPauseButton.textContent = '재생';
                playPauseButton.setAttribute('aria-label', '교리 오디오 재생');
                clearInterval(progressInterval);
                if (event.data === YT.PlayerState.ENDED) {
                    progressBar.style.width = '100%';
                }
            }
        }

        function togglePlayPause() {
            if (player.getPlayerState() === YT.PlayerState.PLAYING) {
                player.pauseVideo();
            } else {
                player.playVideo();
            }
        }

        function updateProgressBar() {
            if (player && player.getDuration) {
                const currentTime = player.getCurrentTime();
                const duration = player.getDuration();
                const progress = (currentTime / duration) * 100;
                progressBar.style.width = progress + '%';
            }
        }
    </script>
</body>
</html>
